git-merge-tree(1)
=================

NAME
----
git-merge-tree - Perform merge without touching index or working tree


SYNOPSIS
--------
[verse]
'git merge-tree' [--write-tree] [<options>] <branch1> <branch2>
'git merge-tree' [--trivial-merge] <base-tree> <branch1> <branch2> (deprecated)

DESCRIPTION
-----------

Performs a merge, but does not make any new commits and does not read
from or write to either the working tree or index.

The second form is deprecated and supported only for backward
compatibility.  It will likely be removed in the future, and will not
be discussed further in this manual.

The first form will merge the two branches, doing a real merge.  A real
merge is distinguished from a trivial merge in that it includes:

  * three way content merges of individual files
  * rename detection
  * proper directory/file conflict handling
  * recursive ancestor consolidation (i.e. when there is more than one
    merge base, creating a virtual merge base by merging the merge bases)
  * etc.

After the merge completes, it will create a new toplevel tree object.
See `OUTPUT` below for details.

OPTIONS
-------

-z::
	Do not quote filenames in the <Conflicted file info> section,
	and end each filename with a NUL character rather than
	newline.  Also begin the messages section with a NUL character
	instead of a newline.  See OUTPUT below for more information.

--exclude-oids-and-modes::
	Instead of writing a list of (mode, oid, stage, path) tuples
	to output for conflicted files, just provide a list of
	filenames with conflicts.

--[no-]messages::
	Write any informational messages such as "Auto-merging <path>"
	or CONFLICT notices to the end of stdout.  If unspecified, the
	default is to include these messages if there are merge
	conflicts, and to omit them otherwise.

--allow-unrelated-histories::
	merge-tree will by default error out if the two branches specified
	share no common history.  This flag can be given to override that
	check and make the merge proceed anyway.

OUTPUT
------

By default, for a successful merge, the output from git-merge-tree is
simply one line:

	<OID of toplevel tree>

Whereas for a conflicted merge, the output is by default of the form:

	<OID of toplevel tree>
	<Conflicted file info>
	<Informational messages>

These are discussed individually below.

OID of toplevel tree
~~~~~~~~~~~~~~~~~~~~

This is a tree object that represents what would be checked out in the
working tree at the end of `git merge`.  If there were conflicts, then
files within this tree may have embedded conflict markers.  This section
is always followed by a newline.

Conflicted file info
~~~~~~~~~~~~~~~~~~~~

This is a sequence of lines with the format

	<mode> <object> <stage> <filename>

The filename will be quoted as explained for the configuration
variable `core.quotePath` (see linkgit:git-config[1]).  However, if
the `--exclude-oids-and-modes` option is passed, the mode, object, and
stage will be omitted.  If `-z` is passed, the "lines" are terminated
by a NUL character instead of a newline character.

Informational messages
~~~~~~~~~~~~~~~~~~~~~~

This always starts with a blank line (or NUL if `-z` is passed) to
separate it from the previous sections, and then has free-form
messages about the merge, such as:

  * "Auto-merging <file>"
  * "CONFLICT (rename/delete): <oldfile> renamed...but deleted in..."
  * "Failed to merge submodule <submodule> (<reason>)"
  * "Warning: cannot merge binary files: <filename>"

Note that these free-form messages will never have a NUL character
in or between them, even if -z is passed.  It is simply a large block
of text taking up the remainder of the output.

EXIT STATUS
-----------

For a successful, non-conflicted merge, the exit status is 0.  When the
merge has conflicts, the exit status is 1.  If the merge is not able to
complete (or start) due to some kind of error, the exit status is
something other than 0 or 1.

USAGE NOTES
-----------

git-merge-tree was written to be low-level plumbing, similar to
hash-object, mktree, commit-tree, update-ref, and mktag.  Thus, it could
be used as a part of a series of steps such as

       NEWTREE=$(git merge-tree --write-tree $BRANCH1 $BRANCH2)
       test $? -eq 0 || die "There were conflicts..."
       NEWCOMMIT=$(git commit-tree $NEWTREE -p $BRANCH1 -p $BRANCH2)
       git update-ref $BRANCH1 $NEWCOMMIT

However, it does not quite fit into the same category of low-level
plumbing commands since the possibility of merge conflicts give it a
much higher chance of the command not succeeding (and NEWTREE containing
a bunch of stuff other than just a toplevel tree).

git-merge-tree was written to provide users with the same information
that they'd have access to if using `git merge`:
  * what would be written to the working tree (the <OID of toplevel tree>)
  * the higher order stages that would be written to the index (the
    <Conflicted file info>)
  * any messages that would have been printed to stdout (the <Informational
    messages>)

MISTAKES TO AVOID
-----------------

Do NOT look through the resulting toplevel tree to try to find which
files conflict; parse the <Conflicted file info> section instead.  Not
only would parsing an entire tree be horrendously slow in large
repositories, there are numerous types of conflicts not representable by
conflict markers (modify/delete, mode conflict, binary file changed on
both sides, file/directory conflicts, various rename conflict
permutations, etc.)

Do NOT interpret an empty <Conflicted file info> list as a clean merge;
check the exit status.  A merge can have conflicts without having
individual files conflict (there are a few types of directory rename
conflicts that fall into this category, and others might also be added
in the future).

Do NOT attempt to guess or make the user guess the conflict types from
the <Conflicted file info> list.  The information there is insufficient
to do so.  For example: Rename/rename(1to2) conflicts (both sides
renamed the same file differently) will result in three different file
having higher order stages (but each only has one higher order stage),
with no way (short of the <Informational messages> section) to determine
which three files are related.  File/directory conflicts also result in
a file with exactly one higher order stage.
Possibly-involved-in-directory-rename conflicts (when
"merge.directoryRenames" is unset or set to "conflicts") also result in
a file with exactly one higher order stage.  In all cases, the
<Informational messages> section has the necessary info, though it is
not designed to be machine parseable.

Do NOT assume all filenames listed in the <Informational messages>
section had conflicts.  Messages can be included for files that have no
conflicts, such as "Auto-merging <file>".

AVOID taking the OIDS from the <Conflicted file info> and re-merging
them to present the conflicts to the user.  This will lose information.
Instead, look up the version of the file found within the <OID of
toplevel tree> and show that instead.  In particular, the latter will
have conflict markers annotated with the original branch/commit being
merged and, if renames were involved, the original filename.  While you
could include the original branch/commit in the conflict marker
annotations when re-merging, the original filename is not available from
the <Conflicted file info> and thus you would be losing information that
might help the user resolve the conflict.

GIT
---
Part of the linkgit:git[1] suite
